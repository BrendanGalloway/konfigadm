{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"konfigadm konfigadm is a node instance configuration tool focused on bootstrapping nodes for container based environments Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Usage : konfigadm [ command ] Available Commands : apply Apply the configuration to the local machine cloud - init Exports the configuration in cloud - init format help Help about any command minify Resolve all lookups and dependencies and export a single config file verify Verify that the configuration has been applied correctly and is in a healthy state version Print the version of konfigadm Flags : - c , --config strings Config files in YAML or JSON format - d , --detect Detect tags to use - h , --help help for konfigadm - v , --loglevel count Increase logging level - t , --tag strings Runtime tags to use, valid tags: debian,ubuntu,redhat,rhel,centos,aws,vmware - e , --var strings Extra Variables to in key=value format Design","title":"Home"},{"location":"#konfigadm","text":"konfigadm is a node instance configuration tool focused on bootstrapping nodes for container based environments","title":"konfigadm"},{"location":"#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Usage : konfigadm [ command ] Available Commands : apply Apply the configuration to the local machine cloud - init Exports the configuration in cloud - init format help Help about any command minify Resolve all lookups and dependencies and export a single config file verify Verify that the configuration has been applied correctly and is in a healthy state version Print the version of konfigadm Flags : - c , --config strings Config files in YAML or JSON format - d , --detect Detect tags to use - h , --help help for konfigadm - v , --loglevel count Increase logging level - t , --tag strings Runtime tags to use, valid tags: debian,ubuntu,redhat,rhel,centos,aws,vmware - e , --var strings Extra Variables to in key=value format","title":"Usage"},{"location":"#design","text":"","title":"Design"},{"location":"commands/","text":"Commands Commands are executed at 3 specific points: pre_commands Pre-commands are used to prepare the environment for execution, OS detection and setting of runtime flags is done in this phase so that they can be used in all other phases. e.g. set an environment variable based on the output of a command. commands Phases can only append to this Commands list. pre_commands Post commands run after all the phases have completed and can be used for cleanup functions are for handing off to other systems.","title":"Commands"},{"location":"commands/#commands","text":"Commands are executed at 3 specific points:","title":"Commands"},{"location":"commands/#pre_commands","text":"Pre-commands are used to prepare the environment for execution, OS detection and setting of runtime flags is done in this phase so that they can be used in all other phases. e.g. set an environment variable based on the output of a command.","title":"pre_commands"},{"location":"commands/#commands_1","text":"Phases can only append to this Commands list.","title":"commands"},{"location":"commands/#pre_commands_1","text":"Post commands run after all the phases have completed and can be used for cleanup functions are for handing off to other systems.","title":"pre_commands"},{"location":"compose/","text":"Merge Behavior / Composability Specs can be combined and merged together - e.g. a cloud provider may install PV drivers and a cluster operator may install organization specific motd/issue files. Configuration from files specified later in the chain overwrite previous configurations. (Similar to the ansible variable precedence rules) Lists are appended to the end of the existing lists (Unsupported in ansible) Maps are merged with existing maps (e.g. hash_behaviour = merge in ansible)","title":"Compose"},{"location":"compose/#merge-behavior-composability","text":"Specs can be combined and merged together - e.g. a cloud provider may install PV drivers and a cluster operator may install organization specific motd/issue files. Configuration from files specified later in the chain overwrite previous configurations. (Similar to the ansible variable precedence rules) Lists are appended to the end of the existing lists (Unsupported in ansible) Maps are merged with existing maps (e.g. hash_behaviour = merge in ansible)","title":"Merge Behavior / Composability"},{"location":"concepts/","text":"Design Mental Models konfigadm intentionally reuses mental models and concepts from kubernetes, golang and ansible these include: Kubernetes declarative model for specifying intent Operators for providing higher-order abstractions Go build tags in comments for specifying behavior based on OS, Cloud etc.. Ansible's way of defining variables and allowing for merging of multiple variable files. Apps Apps provide an abstraction over low-level native and primitive elements, They describe high-level intent for using an application that may require multiple elements to configure. Native Native elements, are not application specific they include packages, repositories, keys, containers, sysctls and environment variables. e.g running echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - will result in the application being transformed into native elements. 1 2 3 4 5 6 7 8 9 10 11 12 13 packageRepos : - deb https://apt.kubernetes.io/ kubernetes-xenial main #+debian - https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 #+redhat gpg : - https://packages.cloud.google.com/apt/doc/apt-key.gpg #+debian - https://packages.cloud.google.com/yum/doc/yum-key.gpg #+redhat - https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg #+redhat packages : - kubelet=1.14.1 - kubeadm=1.14.1 - kubectl=1.14.1 sysctls : vm.swapinness : 1 Native elements are verifiable, i.e. if you specify a container runtime then konfigadm will verify that the runtime has a service enabled and started and that root can connect to the daemon and list running containers. Primitives Primitives are the low-level commands and files that are need to implement native items. For example a package: [curl] native element would create a apt-get install -y curl primitive command on debian systems and yum install -y curl on redhat systems The relationship between the 3 kinds is similar to Deployment, ReplicaSet and Pod. Apps insert and/or update native elements, native elements are then \u201ccompiled\u201d down to primitives.","title":"Concepts"},{"location":"concepts/#design","text":"","title":"Design"},{"location":"concepts/#mental-models","text":"konfigadm intentionally reuses mental models and concepts from kubernetes, golang and ansible these include: Kubernetes declarative model for specifying intent Operators for providing higher-order abstractions Go build tags in comments for specifying behavior based on OS, Cloud etc.. Ansible's way of defining variables and allowing for merging of multiple variable files.","title":"Mental Models"},{"location":"concepts/#apps","text":"Apps provide an abstraction over low-level native and primitive elements, They describe high-level intent for using an application that may require multiple elements to configure.","title":"Apps"},{"location":"concepts/#native","text":"Native elements, are not application specific they include packages, repositories, keys, containers, sysctls and environment variables. e.g running echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - will result in the application being transformed into native elements. 1 2 3 4 5 6 7 8 9 10 11 12 13 packageRepos : - deb https://apt.kubernetes.io/ kubernetes-xenial main #+debian - https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 #+redhat gpg : - https://packages.cloud.google.com/apt/doc/apt-key.gpg #+debian - https://packages.cloud.google.com/yum/doc/yum-key.gpg #+redhat - https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg #+redhat packages : - kubelet=1.14.1 - kubeadm=1.14.1 - kubectl=1.14.1 sysctls : vm.swapinness : 1 Native elements are verifiable, i.e. if you specify a container runtime then konfigadm will verify that the runtime has a service enabled and started and that root can connect to the daemon and list running containers.","title":"Native"},{"location":"concepts/#primitives","text":"Primitives are the low-level commands and files that are need to implement native items. For example a package: [curl] native element would create a apt-get install -y curl primitive command on debian systems and yum install -y curl on redhat systems The relationship between the 3 kinds is similar to Deployment, ReplicaSet and Pod. Apps insert and/or update native elements, native elements are then \u201ccompiled\u201d down to primitives.","title":"Primitives"},{"location":"containers/","text":"Containers 1 2 3 4 5 6 7 containers : - image : \"docker.io/consul:1.3.1\" args : agent -ui -bootstrap -server docker_args : --net=host {% if not private_dns | is_empty %}--dns={{private_dns}}{% endif %} env : CONSUL_CLIENT_INTERFACE : \"{{consul_bind_interface}}\" CONSUL_BIND_INTERFACE : \"{{consul_bind_interface}}\" Arguments Argument Default Description image [Required] Docker image to run service {base image name} The name of the service (e.g systemd unit name or deployment name) env A map of environment variables to pass through labels A map of labels to add to the container docker_args Additional arguments to the docker client e.g. -p 8080:8080 docker_opts Additional options to the docker client e.g. -H unix:///tmp/var/run/docker.sock args Additional arguments to the container volumes List of volume mappings ports List of port mappings commands List of commands to execute inside the container on startup ( files Map of files to mount into the containers templates Map of templates to mount into the container network user-bridge","title":"Containers"},{"location":"containers/#containers","text":"1 2 3 4 5 6 7 containers : - image : \"docker.io/consul:1.3.1\" args : agent -ui -bootstrap -server docker_args : --net=host {% if not private_dns | is_empty %}--dns={{private_dns}}{% endif %} env : CONSUL_CLIENT_INTERFACE : \"{{consul_bind_interface}}\" CONSUL_BIND_INTERFACE : \"{{consul_bind_interface}}\"","title":"Containers"},{"location":"containers/#arguments","text":"Argument Default Description image [Required] Docker image to run service {base image name} The name of the service (e.g systemd unit name or deployment name) env A map of environment variables to pass through labels A map of labels to add to the container docker_args Additional arguments to the docker client e.g. -p 8080:8080 docker_opts Additional options to the docker client e.g. -H unix:///tmp/var/run/docker.sock args Additional arguments to the container volumes List of volume mappings ports List of port mappings commands List of commands to execute inside the container on startup ( files Map of files to mount into the containers templates Map of templates to mount into the container network user-bridge","title":"Arguments"},{"location":"cri/","text":"Container Runtimes (CRI) 1 2 3 4 5 6 7 8 cri : version : 18.6.0 type : docker config : log-driver : json-file log-opts : max-size : 1000m max-file\" : 3","title":"CRI"},{"location":"cri/#container-runtimes-cri","text":"1 2 3 4 5 6 7 8 cri : version : 18.6.0 type : docker config : log-driver : json-file log-opts : max-size : 1000m max-file\" : 3","title":"Container Runtimes (CRI)"},{"location":"environment/","text":"Environment Environment variables are saved to /etc/environment/ and are sourced before any commands runs. 1 2 environment : env1 : \"val: {{env1}}\"","title":"Environment"},{"location":"environment/#environment","text":"Environment variables are saved to /etc/environment/ and are sourced before any commands runs. 1 2 environment : env1 : \"val: {{env1}}\"","title":"Environment"},{"location":"files/","text":"Copying files 1 2 3 files : /etc/some/file : file /etc/some/file2 : file2","title":"Files"},{"location":"files/#copying-files","text":"1 2 3 files : /etc/some/file : file /etc/some/file2 : file2","title":"Copying files"},{"location":"installation/","text":"Installation Ubuntu / Debian 1 2 wget https://github.com/flanksource/konfigadm/releases/download/v0.5.3/konfigadm.deb dpkg -i konfigadm.deb Centos / Fedora / Redhat 1 rpm -i https://github.com/flanksource/konfigadm/releases/download/v0.5.3/konfigadm.rpm Binary 1 wget -O /usr/bin/konfigadm https://github.com/flanksource/konfigadm/releases/download/v0.5.3/konfigadm && chmod +x /usr/bin/konfigadm","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#ubuntu-debian","text":"1 2 wget https://github.com/flanksource/konfigadm/releases/download/v0.5.3/konfigadm.deb dpkg -i konfigadm.deb","title":"Ubuntu / Debian"},{"location":"installation/#centos-fedora-redhat","text":"1 rpm -i https://github.com/flanksource/konfigadm/releases/download/v0.5.3/konfigadm.rpm","title":"Centos / Fedora / Redhat"},{"location":"installation/#binary","text":"1 wget -O /usr/bin/konfigadm https://github.com/flanksource/konfigadm/releases/download/v0.5.3/konfigadm && chmod +x /usr/bin/konfigadm","title":"Binary"},{"location":"integration/","text":"Integration konfigadm can be used to wrap any other configuration management tool, it has the advantage of being able to install the configuration management tool, copy the resources required for the tool and execute the tool all in one convenient package. ansible config.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 packages : - ansible files : /root/playbook.yml : | --- - name: This is a hello-world example hosts: all connection: local tasks: - name: Create a file called '/tmp/testfile.txt' copy: content: hello world dest: /tmp/testfile.txt commands : - ansible-playbook -i 'localhost, ' /root/playbook.yml 1 konfigadm apply -c config.yml The playbook and other files can also be externalized by just specifying a relative path to the files to include. config.yml 1 2 3 4 5 6 packages : - ansible files : /root/playbook.yml : playbook.yml commands : - ansible-playbook -i 'localhost, ' /root/playbook.yml playbook.yml 1 2 3 4 5 6 7 8 - name : This is a hello-world example hosts : all connection : local tasks : - name : Create a file called '/tmp/testfile.txt' copy : content : hello world dest : /tmp/testfile.txt","title":"Integration"},{"location":"integration/#integration","text":"konfigadm can be used to wrap any other configuration management tool, it has the advantage of being able to install the configuration management tool, copy the resources required for the tool and execute the tool all in one convenient package.","title":"Integration"},{"location":"integration/#ansible","text":"config.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 packages : - ansible files : /root/playbook.yml : | --- - name: This is a hello-world example hosts: all connection: local tasks: - name: Create a file called '/tmp/testfile.txt' copy: content: hello world dest: /tmp/testfile.txt commands : - ansible-playbook -i 'localhost, ' /root/playbook.yml 1 konfigadm apply -c config.yml The playbook and other files can also be externalized by just specifying a relative path to the files to include. config.yml 1 2 3 4 5 6 packages : - ansible files : /root/playbook.yml : playbook.yml commands : - ansible-playbook -i 'localhost, ' /root/playbook.yml playbook.yml 1 2 3 4 5 6 7 8 - name : This is a hello-world example hosts : all connection : local tasks : - name : Create a file called '/tmp/testfile.txt' copy : content : hello world dest : /tmp/testfile.txt","title":"ansible"},{"location":"k8s/","text":"Example chain for kubernetes Kubernetes The kubernetes config element is the primary purpose of konfigadm , configuring machines so that they have all pre-requisites met for running kubeadm Install and mark the specific versions of kubeadm , kubelet , kubectl , kubernetes-cni Install a container runtime if not specified Prepull images required to run kubernetes Set any sysctl values that are required 1 konfigadm apply -c k8s.yml k8s.yml 1 2 kubernetes : version : 1.14.1 The config can also be specified via stdin: echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - Specifying a kubernetes app is equivalent to: 1 2 3 4 5 6 7 8 9 10 11 12 13 packageRepos : - deb https://apt.kubernetes.io/ kubernetes-xenial main #+debian - https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 #+redhat gpg : - https://packages.cloud.google.com/apt/doc/apt-key.gpg #+debian - https://packages.cloud.google.com/yum/doc/yum-key.gpg #+redhat - https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg #+redhat packages : - kubelet=1.14.1 - kubeadm=1.14.1 - kubectl=1.14.1 sysctls : vm.swapinness : 1","title":"Kubernetes"},{"location":"k8s/#example-chain-for-kubernetes","text":"","title":"Example chain for kubernetes"},{"location":"k8s/#kubernetes","text":"The kubernetes config element is the primary purpose of konfigadm , configuring machines so that they have all pre-requisites met for running kubeadm Install and mark the specific versions of kubeadm , kubelet , kubectl , kubernetes-cni Install a container runtime if not specified Prepull images required to run kubernetes Set any sysctl values that are required 1 konfigadm apply -c k8s.yml k8s.yml 1 2 kubernetes : version : 1.14.1 The config can also be specified via stdin: echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - Specifying a kubernetes app is equivalent to: 1 2 3 4 5 6 7 8 9 10 11 12 13 packageRepos : - deb https://apt.kubernetes.io/ kubernetes-xenial main #+debian - https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 #+redhat gpg : - https://packages.cloud.google.com/apt/doc/apt-key.gpg #+debian - https://packages.cloud.google.com/yum/doc/yum-key.gpg #+redhat - https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg #+redhat packages : - kubelet=1.14.1 - kubeadm=1.14.1 - kubectl=1.14.1 sysctls : vm.swapinness : 1","title":"Kubernetes"},{"location":"native_files/","text":"Copying files 1 2 3 4 5 6 7 filesystem : /root/script.sh : content : | #!/bin/bash echo Hello world permissions : \"0755\" owner : \"root\"","title":"Files"},{"location":"native_files/#copying-files","text":"1 2 3 4 5 6 7 filesystem : /root/script.sh : content : | #!/bin/bash echo Hello world permissions : \"0755\" owner : \"root\"","title":"Copying files"},{"location":"packages/","text":"Packages Packages can include modifiers: - removed if installed + update to the latest = mark to prevent future automatic updates 1 2 3 4 5 packages : - socat - -docker-common - -docker - =docker-ce==18.06 Packages can also leverage runtime flags: 1 2 3 4 5 6 packages : - netcat #+debian - nmap-ncat #+redhat - open-vm-tools #+vmware - aws-cli #+aws - azure-cli #+azure","title":"Packages"},{"location":"packages/#packages","text":"Packages can include modifiers: - removed if installed + update to the latest = mark to prevent future automatic updates 1 2 3 4 5 packages : - socat - -docker-common - -docker - =docker-ce==18.06 Packages can also leverage runtime flags: 1 2 3 4 5 6 packages : - netcat #+debian - nmap-ncat #+redhat - open-vm-tools #+vmware - aws-cli #+aws - azure-cli #+azure","title":"Packages"},{"location":"syntax/","text":"konfigadm konfigadm is a node instance configuration tool focused on bootstrapping nodes for container based environments Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Usage : konfigadm [ command ] Available Commands : apply Apply the configuration to the local machine cloud - init Exports the configuration in cloud - init format help Help about any command minify Resolve all lookups and dependencies and export a single config file verify Verify that the configuration has been applied correctly and is in a healthy state version Print the version of konfigadm Flags : - c , --config strings Config files in YAML or JSON format - d , --detect Detect tags to use - h , --help help for konfigadm - v , --loglevel count Increase logging level - t , --tag strings Runtime tags to use, valid tags: debian,ubuntu,redhat,rhel,centos,aws,vmware - e , --var strings Extra Variables to in key=value format Design Mental Models konfigadm intentionally reuses mental models and concepts from kubernetes, golang and ansible these include: Kubernetes declarative model for specifying intent Operators for providing higher-order abstractions Go build tags in comments for specifying behavior based on OS, Cloud etc.. Ansible's way of defining variables and allowing for merging of multiple variable files. Apps Apps provide an abstraction over low-level native and primitive elements, They describe high-level intent for using an application that may require multiple elements to configure. Kubernetes The kubernetes config element is the primary purpose of konfigadm , configuring machines so that they have all pre-requisites met for running kubeadm Install and mark the specific versions of kubeadm , kubelet , kubectl , kubernetes-cni Install a container runtime if not specified Prepull images required to run kubernetes Set any sysctl values that are required 1 konfigadm apply -c k8s.yml k8s.yml 1 2 kubernetes : version : 1.14.1 The config can also be specified via stdin: echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - 1 2 kubernetes : version : 1.14.1 Container Runtimes (CRI) 1 2 3 4 5 6 7 8 cri : version : 18.6.0 type : docker config : log-driver : json-file log-opts : max-size : 1000m max-file\" : 3 Native Native elements, are not application specific they include packages, repositories, keys, containers, sysctls and environment variables. e.g running echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - will result in the application being transformed into native elements. 1 2 3 4 5 6 7 8 9 10 11 12 13 packageRepos : - deb https://apt.kubernetes.io/ kubernetes-xenial main #+debian - https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 #+redhat gpg : - https://packages.cloud.google.com/apt/doc/apt-key.gpg #+debian - https://packages.cloud.google.com/yum/doc/yum-key.gpg #+redhat - https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg #+redhat packages : - kubelet=1.14.1 - kubeadm=1.14.1 - kubectl=1.14.1 sysctls : vm.swapinness : 1 Native elements are verifiable, i.e. if you specify a container runtime then konfigadm will verify that the runtime has a service enabled and started and that root can connect to the daemon and list running containers. Primitives Primitives are the low-level commands and files that are need to implement native items. For example a package: [curl] native element would create a apt-get install -y curl primitive command on debian systems and yum install -y curl on redhat systems The relationship between the 3 kinds is similar to Deployment, ReplicaSet and Pod. Apps insert and/or update native elements, native elements are then \u201ccompiled\u201d down to primitives. ``` Services Natives","title":"Syntax"},{"location":"syntax/#konfigadm","text":"konfigadm is a node instance configuration tool focused on bootstrapping nodes for container based environments","title":"konfigadm"},{"location":"syntax/#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Usage : konfigadm [ command ] Available Commands : apply Apply the configuration to the local machine cloud - init Exports the configuration in cloud - init format help Help about any command minify Resolve all lookups and dependencies and export a single config file verify Verify that the configuration has been applied correctly and is in a healthy state version Print the version of konfigadm Flags : - c , --config strings Config files in YAML or JSON format - d , --detect Detect tags to use - h , --help help for konfigadm - v , --loglevel count Increase logging level - t , --tag strings Runtime tags to use, valid tags: debian,ubuntu,redhat,rhel,centos,aws,vmware - e , --var strings Extra Variables to in key=value format","title":"Usage"},{"location":"syntax/#design","text":"","title":"Design"},{"location":"syntax/#mental-models","text":"konfigadm intentionally reuses mental models and concepts from kubernetes, golang and ansible these include: Kubernetes declarative model for specifying intent Operators for providing higher-order abstractions Go build tags in comments for specifying behavior based on OS, Cloud etc.. Ansible's way of defining variables and allowing for merging of multiple variable files.","title":"Mental Models"},{"location":"syntax/#apps","text":"Apps provide an abstraction over low-level native and primitive elements, They describe high-level intent for using an application that may require multiple elements to configure.","title":"Apps"},{"location":"syntax/#kubernetes","text":"The kubernetes config element is the primary purpose of konfigadm , configuring machines so that they have all pre-requisites met for running kubeadm Install and mark the specific versions of kubeadm , kubelet , kubectl , kubernetes-cni Install a container runtime if not specified Prepull images required to run kubernetes Set any sysctl values that are required 1 konfigadm apply -c k8s.yml k8s.yml 1 2 kubernetes : version : 1.14.1 The config can also be specified via stdin: echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - 1 2 kubernetes : version : 1.14.1","title":"Kubernetes"},{"location":"syntax/#container-runtimes-cri","text":"1 2 3 4 5 6 7 8 cri : version : 18.6.0 type : docker config : log-driver : json-file log-opts : max-size : 1000m max-file\" : 3","title":"Container Runtimes (CRI)"},{"location":"syntax/#native","text":"Native elements, are not application specific they include packages, repositories, keys, containers, sysctls and environment variables. e.g running echo \"kubernetes: {version: 1.14.1}\" | konfigadm minify -c - will result in the application being transformed into native elements. 1 2 3 4 5 6 7 8 9 10 11 12 13 packageRepos : - deb https://apt.kubernetes.io/ kubernetes-xenial main #+debian - https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 #+redhat gpg : - https://packages.cloud.google.com/apt/doc/apt-key.gpg #+debian - https://packages.cloud.google.com/yum/doc/yum-key.gpg #+redhat - https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg #+redhat packages : - kubelet=1.14.1 - kubeadm=1.14.1 - kubectl=1.14.1 sysctls : vm.swapinness : 1 Native elements are verifiable, i.e. if you specify a container runtime then konfigadm will verify that the runtime has a service enabled and started and that root can connect to the daemon and list running containers.","title":"Native"},{"location":"syntax/#primitives","text":"Primitives are the low-level commands and files that are need to implement native items. For example a package: [curl] native element would create a apt-get install -y curl primitive command on debian systems and yum install -y curl on redhat systems The relationship between the 3 kinds is similar to Deployment, ReplicaSet and Pod. Apps insert and/or update native elements, native elements are then \u201ccompiled\u201d down to primitives. ```","title":"Primitives"},{"location":"syntax/#services","text":"","title":"Services"},{"location":"syntax/#natives","text":"","title":"Natives"},{"location":"sysctl/","text":"Systctl 1 2 3 sysctls : net.ipv6.conf.all.disable_ipv6 : 1 net.ipv6.conf.default.disable_ipv6 : 1","title":"Sysctl"},{"location":"sysctl/#systctl","text":"1 2 3 sysctls : net.ipv6.conf.all.disable_ipv6 : 1 net.ipv6.conf.default.disable_ipv6 : 1","title":"Systctl"},{"location":"systemd/","text":"","title":"Systemd"},{"location":"tags/","text":"Runtime Tags 1 2 3 konfigadm minify -c config.yml --tags ubuntu # tags are detected by default when using the apply command konfigadm apply -c config Similar to go build tags, runtime tags provide a way of deciding what gets run, the following tags are provided by default: centos ubuntu fedora debian matched for all debian based distros (ubuntu) rhel redhat matched for all redhat based distros (centos, fedora, rhel, amazon linux) amazonLinux aws matched when running inside Amazon Web Services azure matched when running inside Azure vmware matched when running on a vSphere Hypervisor kvm matched when running on a KVM Hypervisor Tags can be applied to the following elements: * packages * packageRepos * packageKeys * commands, pre_commands, post_commands Multiple tags can be specified in which case all tags must match. 1 2 3 packages : # only install aws-cli on debian based system running in AWS - aws-cli #+debian +aws Tags can be negated using ! 1 2 3 pre_commands : # attach a rhel subscription, but only if we are not running in AWS - subscription manager attach #+rhel !aws","title":"Tags"},{"location":"tags/#runtime-tags","text":"1 2 3 konfigadm minify -c config.yml --tags ubuntu # tags are detected by default when using the apply command konfigadm apply -c config Similar to go build tags, runtime tags provide a way of deciding what gets run, the following tags are provided by default: centos ubuntu fedora debian matched for all debian based distros (ubuntu) rhel redhat matched for all redhat based distros (centos, fedora, rhel, amazon linux) amazonLinux aws matched when running inside Amazon Web Services azure matched when running inside Azure vmware matched when running on a vSphere Hypervisor kvm matched when running on a KVM Hypervisor Tags can be applied to the following elements: * packages * packageRepos * packageKeys * commands, pre_commands, post_commands Multiple tags can be specified in which case all tags must match. 1 2 3 packages : # only install aws-cli on debian based system running in AWS - aws-cli #+debian +aws Tags can be negated using ! 1 2 3 pre_commands : # attach a rhel subscription, but only if we are not running in AWS - subscription manager attach #+rhel !aws","title":"Runtime Tags"},{"location":"templates/","text":"Templating konfigadm can execute Jinja style templates using the pongo2 library config.yml 1 2 templates : /etc/package-list : file.tpl file.tpl 1 2 3 {% for pkg in packages %} Installed package: {{ pkg }} {% endfor %}","title":"Templates"},{"location":"templates/#templating","text":"konfigadm can execute Jinja style templates using the pongo2 library config.yml 1 2 templates : /etc/package-list : file.tpl file.tpl 1 2 3 {% for pkg in packages %} Installed package: {{ pkg }} {% endfor %}","title":"Templating"}]}